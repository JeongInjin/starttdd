#테스트 주도 개발 시작하기 - 최범균
- 개인적인 메모


---

- 첫번째 테스트는 가장 쉽거나 가장 예외적인 상황을 선택해야 한다.
- tdd 는 테스트를 통과시킬 만큼의 코드만 작성한다.
---
- 기능을 검증하는 테스트를 먼저 작성한다.
- 작성한 테스트를 통과하지 못하면 테스트를 통과할 만큼만 코드를 작성한다.
- 테스트를 통과한 뒤에는 개선할 코드가 있으면 리팩토링을 진행한다.
- 리팩토링 후에는 기존 테스트의 기능이 망가지지 않았는지 확인한다.
- 이 과정을 반복하면서 검진적으로 기능을 완성해 나간다. 이것이 전형적인 TDD 의 흐름이다.


- `TDD 사이클을 **"레드-그린-리팩터"** 로 부르기도 한다.`
---
- Chapter02 - 암호검사기 
- 테스트 코드 작성 순서는 아래와 같이 진행하였다.
  1. 쉬운 경우에서 어려운 경우로 진행
  2. 예외적인 경우에는 정상인 경우로 진행

- 막힌다면?
  - 상수를 비교해서 테스트를 통과시켜보자.
  - 테스트를 추가하면서 구현을 일반화. 

- 레팩토링은 언제?
  - 테스트 대상 코드에서 상수를 변수로 바꾸거나 변수 이름을 변경하는 것과 같은 작은 리팩토링은 발견 즉시 실행한다.
  - 메서드 추출과 같은 구조에 영향을 주는 리팩토링은 큰 틀에서 구현 흐름이 눈에 들어오기 시작한 뒤에 진행하자.

---
- 대역
  - mock 객체를 너무 남발하지말고, 대역 클래스를 만드는 것도 생각해보자.
  - 대역 클래스를 만드는게 귀찮게 느껴지겠지만, 모의 객체를 시작하기 시작하면, 결과 검증 코드가 길어지고, 코드가 복잡해진다.
    - 하나의 테스트를 위해 여러가지 모의객체를 사용하다보면 복잡도가 배로 증가한다
    - 모의 객체는 기본적으로 메서드 호출 여부를 검증하는 수단이기 때문에 테스트 대상과 모의 객체 간의 상호작용이 조금만 봐뀌어도 테스트가 깨지기 쉽다.
  - DAO 나 레포지토리와 같은 저장소에 대한 대역은 모의 객체를 사용하는 것보다 메모리를 이용한 가짜 구현을 사용하는 것이 테스트 코드 관리에 유리하다.

---
- 테스트를 어렵게 하는 코드들
  - 하드 코딩된 경로
  - 의존 객체를 직접 생성
  - 정적 메서드 사용
    - ex)코드: AuthUtil.authorize => AuthUtil 클래스가 인증 서버와 통신하는 경우 이코드를 테스트하려면 동작하고 있는 인증 서버가 필요하다.
    - 인증서버 아이디, 비밀번호 등도 필요하고, 변경될 수도있다.
  - 실행 시점에 따라 달라지는 결과
    - LocalDate.now()같은..
    - Random 값을 사용하는 경우..
    - 역할이 섞여 있는 코드
    - 메서드 중간에 소켓 통신 코드가 포함되어 있다.
      - 실제를 대체할 서버를 로컬에 띄워서 처리할 수 있다..
    - 테스트 대상이 사용하는 의존 대상 클래스나 메서드가 final 이다.이 경우 대역으로 대체가 어려울 수 있다.

- 그래서 어떻게?테스트할 수 있는 코드로 변경할까?
  - 하드 코딩된 상수를 생성자나 메서드 파라미터로 받기.
  - 시간이나 임의 값 생성 기능 분리하기
  - 외부 라이브러리 직접 사용하지 말고 감싸서 사용하기
  - WireMock 을 이용한 REST 클라이언트 테스트하기.
---

- 하나의 테스트에는 한가지만 검증하자.
- 과도하게 구현하지 않기
  - 내부 구현은 언제든지 비뀔 수 있기 때문에 테스트 코드는 내부 구현보다 실행 결과를 검증해야 한다.
- 셋업을 이용해 중복된 상황을 설저하지 않기
- 

